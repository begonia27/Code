# 第七章 使用数组

* [1.1 定义数组](#11-定义数组)

  * [1.1.1 使用数组计数](#111-使用数组计数)

  * [1.1.2 产生Fibonacci数](#112-产生Fibonacci数)

  * [1.1.3 使用数组产生质数](#113-使用数组产生质数)

---

* [1.2 数组初始化](#12-数组初始化)

---

* [1.3 字符数组](#13-字符数组)

  * [1.3.1 使用数组完成计数](#131-使用数组完成计数)

  * [1.3.2 const修饰符](#132-const修饰符)

---

* [1.4 多维数组](#14-多维数组)

---

* [1.5 变量长度的数组](#15-变量长度的数组)

---

## 1.1 定义数组

1. >使用数组，我们可以定义一个变量 *$grades$* ，用于代表 **一组** 变量，而不是单个变量。
2. >我们可以使用 **下标** 或者 **索引** 的方式访问这种变量中的 **每一个** 。
3. >将一组 **相关联的数据** 保存在 **单个数组** 之中，我们就可以 **简明高效的开发程序** 了。
4. >在 *$C$* 语言中，我们用下面的记号来表示 **下标** ： `x[i]` 。
5. >因为 *$C$* 语言中 **数组的下标** 从 *$0$* 开始，所以表达式 `grades[0]` 实际上代表的是 **第一个元素** 。
6. >在使用数组的时候，请读者务必记住，数组的 **第一个元素** 用下标 *$0$* 访问，数组的 **最后一个元素的下标** 是数组中元素的个数减去 *$1$* 。
7. >除了 **整数常量** 之外，任何结果是 **整型数的表达式** 都可以放在 **方括号内** ，用作 **数组的下标** 。
8. >和普通变量一样，在使用数组之前，我们必须先 **声明** 它。
9. >数组的声明包含 **两个要素** ：一个是数组中 **保存的元素类型** ，如 *$int$* 、 *$float$* 、 *$char$* ；另外一个是数组中需要保存的 **元素最大个数** 。
10. >*$C$* 语言的 **编译器** 使用这些信息计算数组需要的 **存储空间** 。
11. >`int grades[100]` 这个语句声明了一个 **能够容纳** *$100$* 个整数的整型数组 *$grades$* ，这个数组的有效下标是从 *$0$* 到 *$99$* 。
12. >读者在 *$C$* 语言中使用 **数组** 的时候，一定要留意 **下标的有效性** 。
13. >*$C$* 语言本身对于下标并 **不进行范围检查** ，因此如果我们使用该数组的 *$150$* 号元素，程序运行并 **不一定会报错** ，但是很可能 **产生不可预料或者非预期的运行效果** 。
14. >无论数组的类型是 *$int$* 、*$float$* 还是 *$char$* ，我们都可以像使用普通变量那样使用这些 **数组的元素** 。比如给它们 **赋值** 、**在终端上输出** 、 **执行加减法操作** 等。
15. >在编写程序的时候，我们不要对数组中 **未初始化的值** 进行任何假定。

---

### 1.1.1 使用数组计数

1. >由于 *$0$* 号元素的存在，数组能容纳的元素的 **个数** 总是比能使用的 **最大下标大 *$1$*** 。

---

### 1.1.2 产生Fibonacci数

1. >程序 *$7.3$* 产生前 *$15$* 个 **斐波那契数列** 。前两个 *$Fibonacci$* 数， *$F_0$* 和 *$F_1$* ，分别被定义为 *$0$* 和 *$1$* ，随后，每一个 *$Fibonacci$* 数 *$F_1$* 被定义为前面两个 *$Fibonacci$* 数 *$F_i-1$* 和 *$F_i-2$* 之和。也就是说，`F_2` 等于 `F_1` 与 `F_0` 之和。在前面的程序中，这个步骤对应于数组元素 *$Fibonacci[0]$* 与 *$Fibonacci[1]$* 相加，并将结果赋予数组元素 *$Fibonacci[2]$* 。按照类似的步骤，我们在程序中利用 **循环** 计算出 *$F_2$* 到 *$F_14$* 的值，也就是 *$Fibonacci[2]$* 到 *$Fibonacci[14]$* 。
2. >*$Fibonacci$* 数在 **数学** 和 **程序设计算法领域** 有很多实际应用,例如：**兔子问题** 。

---

### 1.1.3 使用数组产生质数

1. >虽然在产生较小的质数表时， **效率的问题** 并不是很重要，但是在产生大型的质数表，**算法的效率** 就是一个中关重要的问题了。
2. >如果一个数不能被任何质数整除，那么这个数就是一个 **质数** 。
3. >任何一个质数都可以分解为 **多个质数的积** 。
4. >为了进一步优化程序的效率，我们还可以使用另外一个定理：**任何一个非指数的整数** ，肯定会有一个 **小于其平方根** 的质因数。也就是说，在判断某个数是否为质数时，我们只需要尝试那些 **小于其平方根的质数** 就可以了。

---

## 1.2 数组初始化

1. >我们可以在声明数组的时候 **初始化其内容** 。
2. >在声明数组的时候，从 **第一个元素** 开始逐个列出其 **初始值** ，并将这些值用 **逗号** 隔开，最后用 **一对大括号** 将其包围起来即可。
3. >下面的语句声明了一个有 *$5$* 个元素的整型数组，并将其中的每一个元素初始化为 *$0$* ：

```C
int counters[5] = {0, 0, 0, 0, 0};
```

1. >我们也可以用类似的方法初始化字符数组：例如定义一个拥有 *$5$* 个元素的字符型数组 *$letters$* ，并将其中的 *$5$* 个元素分别初始化为 `'a'` 、 `'b'` 、 `'c'` 、 `'d'` 、`'e'` 。
2. >在声明数组的时候，我们 **并不需要** 给出和数组所能容纳元素数量 **同样多的初始值** 。如果给出的初始值 **小于** 数组所能容纳元素的 **个数** ， *$C$* 语言则只初始化 **有限个数组元素** ，数组中的 **其他元素** 将被初始化为 *$0$* 。
3. >我们可以在初始化值列表中使用 **方括号** 和 **小标** 指定我们要初始化哪些数组元素，这些下标可以按照 **任意的顺序** 排列，如下所示：

```C
float sample_data[500] = {[2] = 500.5, [1] = 300.3, [0] = 100.0};
```

1. >不幸的是， *$C$* 语言对于数组初始化 **没有提供任何快捷的形式** 。比如我们不能声明一个有 *$500$* 个元素的数组，然后使用一个重复量将所有的数组元素都初始化为 *$1$* 。实际上，我们只能 **逐个写出这些初始值** 。这种时候，我们最好在程序中使用 **某种形式的循环** 来完成 **初始化的工作** 。

---

## 1.3 字符数组

1. >*$C$* 语言允许我们在声明数组的时候 **不指定数组的长度** 。这个时候，数组的长度由 **初始化列表中值的个数决定** 。
2. >如果使用了带有下标的初始化列表形式，那么 *$c$* 语言使用 **初始化列表中最大下标** 决定数组的长度。

---

### 1.3.1 使用数组完成计数

1. >编写一个 **程序完成转换工作** 的话，我们还有几件事情需要考虑。首先 **算法产生数字的顺序是反过来** 的，这一点让我们觉得有些不满意。我们当然不能期望读者从右向左或者从下向上阅读程序的输出，我们应该想办法 **修正** 这个问题。

---

### 1.3.2 const修饰符

1. >*$C$* 语言编译器允许我们使用  *$const$* 修饰符，标明那些在程序运行期间 **值不会变化的变量** 。也就是说，我们用这个 **修饰符** 告诉 **编译器** ，该变量的值在运行期间为 **常量** 。
2. >*$C$* 语言中 *$const$* 修饰符的 **主要动机** 在于，编译器可以决定，将 *$const$* 变量放置到 **只读内存** 中。
3. >下面，我们给出一个使用 *$const￥* 修饰符的一个例子：

```C
const double pi = 3.141592654;
```

1. >上面的语句声明了一个 *$const$* 变量 *$pi$* ，这个语句告诉编译器，程序在运行过程中 **不会修改** 变量 *$pi$* 的值。
2. >使用 *$const修饰符$* 可以 **提高程序的可读性** 。

---

## 1.4 多维数组

1. >迄今为止，我们介绍的所有数组都是 **线性的**  -- 也就是说，它们 **只有一个维度** 。
2. >*$C$* 语言允许定义 **任意维度的数组** 。
3. >二维数组最常见的用途是 **处理矩阵** 。
4. >在数学中，我们通常使用 **双下标** 来引用 **矩阵中的元素** 。如果我们将矩阵称为 *$M$* 的话，那么 *$M_ij$* 就代表第 *$i$* 行第 *$j$* 列上的那个元素。
5. >我们可以用类似的方式引用 *$C$* 语言 **二维数组中的元素** 。不过，由于 *$C$* 语言通常从 *$0$* 开始计数，因此矩阵的第一行实际上在 *$C$* 语言中为第 *$0$* 行，矩阵的第一列在 *$c$* 语言中为第 *$0$* 列。
6. >在书写 **二维数组的初始列表** 时，所有的值 **按行** 写出，每一行的初始化数据用 **大括号** 括起来。
7. >在界定每一行初始化数据的大括号后面，除了 **最后一行** ，都需要加上一个 **逗号** 。
8. >初始化列表中的大括号实际上 **并不是必须** 的，如果没有大括号的话， *$C$* 语言也将 **按照行** 来读入这些初始化值。
9. >与一维数组相类似， *$C$* 语言允许我们在声明数组的时候 **只初始化部分元素** 。
10. >如果我们 **只初始化数组的一部分** ，那么初始化列表中的 **大括号** 就是 **必须** 的了。

---

## 1.5 变量长度的数组

1. >*$C$* 语言允许我们 **使用变量** 指定 **数组的长度** 。
2. >在开始计算之前，程序还要对用户输入的数字进行 **范围检查** ，这是一个很好的 **编程习惯** 。
3. >如果输入的 **数字超出范围** ，我们的程序仅仅 **打印出一条消息** ，然后 **执行return1这个语句** 。
4. >*$C$* 语言在程序执行的时候遇到 *$return$* 语句，将会 **跳过所有剩余的语句** ， **立刻结束** 程序的运行。
5. >*$C$* 语言中有一种名为 **动态内存分配** 的技术，该技术允许程序在运行时，为数组 **分配内存空间** ，这种技术 **使用标准库函数**  *$malloc$* 和 *$calloc$* 。

---
