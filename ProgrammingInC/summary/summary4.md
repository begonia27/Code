# 第4章 变量、数据类型和算术表达式

* [1.1 使用变量](#11-使用变量)

---

* [1.2 数据类型与常量](#12-数据类型与常量)

  * [1.2.1 基本数据类型int](#121-基本数据类型int)

  * [1.2.2 存储空间与范围](#122-存储空间与范围)

  * [1.2.3 浮点数类型float](#123-浮点数类型float)

  * [1.2.4 扩展精度的浮点类型double](#124-扩展精度的浮点类型double)

  * [1.2.5 字符类型char](#125-字符类型char)

  * [1.2.6 布尔类型_Bool](#126-布尔类型_bool)

  * [1.2.7 类型修饰符：long, long long, short, unsigned和signed](#127-类型修饰符long-long-long-short-unsigned和signed)

---

* [1.3 使用算术表达式](#13-使用算术表达式)

  * [1.3.1 整数算术和单目减法操作符](#131-整数算术和单目减法操作符)

  * [1.3.2 余数操作符](#132-余数操作符)

  * [1.3.3 整型数与浮点数之间的转换](#133-整型数与浮点数之间的转换)

---

* [1.4 结合运算和赋值：运算赋值操作符](#14-结合运算和赋值运算赋值操作符)

---

* [1.5 类型_Complex和_Imagiary](#15-类型_complex和_imagiary)

---

## 1.1 使用变量

1. >对于早期的程序员来说，使用 **机器语言** 书写程序时一件繁重的工作。程序员必须把所有的 **计算机指令** 表达为 **二进制的数字** ，然后才能将程序输入计算机。
2. >对于早期的程序员来说，如果需要 **存取** 内存中的数据，程序员还必须使用特殊格式的 **内存地址** 。
3. >现代的编程语言让程序员可以使用这些符号（这些符号被称为 **变量** ）来代表计算中使用的 **数据** 以及 **结果** 。
4. >我们可以根据现存储数据的 **类别** 和 **作用** ，为符号选择合适的名称 **（变量名）** 。
5. >*$C$* 语言提供的 **数据类型** 不仅限于 **整数** ，我们还可以声明 **浮点数** 、 **字符** 甚至是用来表示计算机中某个内存位置的 **指针类型变量** 。
6. >变量的 **命名规则** 很简单：一个变量名开始必须是 **一个字母** 或者 **下画线`_`** ,后面可以是 **字母** （大写或者小写）、 **下画线** 或者 **数字** （ `0 - 9` ）的任意组合。
7. >下面的变量名则是不合法的： *$sum$value$* ，因为变量名中不允许使用 *$* 符号； *$piece flag$* ，因为 **变量名中不允许使用空格** ； *$3Spencer$* ，因为数字不能作为变量名的开始； *$int$* ，因为 *$int$* 是一个 **保留字** 。
8. >所谓的保留字就是：对于 *$C$* 语言的编译器来说有着 **特殊意义** 的符号。一般来说， **所有的保留字都不能用作变量名** 。
9. >虽然变量名的 **长度是任意的** ，但是对于编译器来说，只有前 *$63$* 个字符是 **有意义的** 。在某些特殊的情况下，则只有前 *$31$* 个字符有意义。
10. >合适的变量名能够大大增加程序的 **可读性** ，从而减少程序员在 **调试**和 **文档** 方面的工作量。

---

## 1.2 数据类型与常量

1. >除了整型变量以外， *$C$* 语言还有四种基本的 **数据类型** ： *$$float$$* 、 *$$double$$* 、 *$char$* 和 *_$Bool$* 。
2. >*$$float$$* 类型的变量可以存储 **浮点数**（也就是带有小数点的数字）。
3. >*$$double$$* 类型与 *$$float$$* 类型相同，但是它的 **精度** 是 *$$float$$* 类型的 **两倍** 。
4. >*$char$* 类型的变量可以用来 **存储单个字符** ，如字母 *$a$* ，数字 *$6$* ，或者一个分号;。
5. >*_$Bool$* 类型只能用来存储 **数字** *$0$* 或者 *$1$* 。这个变量可以用来表示 **开关** 、 **是否** 、 **真假** 等。
6. >在 *$C$* 语言中，任何 **数字** 、 **单个字符** 或者 **字符串** 都被看作是 **常量** 。
7. >全部由 **常量** 组成的 **表达式** 就是常量表达式。

### 1.2.1 基本数据类型int

1. >在 *$C$* 语言中，整数是一个或者多个数字组成的 **序列** 。如果在这个序列前面有一个减号（-），这个数字则是一个负数。
2. >整数之间 **不能含有大空格** ，大于 *$999$* 的整数也 **不能包含逗号** 。
3. >*$C$* 语言用 **两种专门的格式** 来表示不是以 *$10$* 为基数的整数。
4. >如果一个整数的开始数字是 *$0$* ，那么这个数字就被看做一个 **八进制数** 。
5. >八进制数的 **每一个数字** 只能是 `0 - 7` 。
6. >如果要在终端上 **显示八进制数** ，可以在 *$$printf$$* 函数的 **格式化字符串中** 使用 *%$o$* 。
7. >*%$o$* 输出的八进制数前面不显示 *$0$* ，如果要显示 *0* ，则需要使用 *%#$o$* 。
8. >如果一个整数常量的 **开始符号** 是 *$0$* 和 *$x$* （ **无论是大写还是小写** ），这个数字就被当做是 **十六进制数** 。*$0x$* 后面的数字都是 **十六进制的数字** ，这些数字包括 `0 - 9` 和 `a - f`（或者 `A - F` ），其中 **字母** 用来表示 *$10-15$* 。
9. >格式化输出符号中使用 **大写** 的 *$X$* ，如 *$%X$* 或者 *$%#X$* ，那么在 **终端** 上 **输出** 的十六进制数前面的 *$X$* 和字母就是 **大写** 的。

---

### 1.2.2 存储空间与范围

1. >无论是 **整数** 、 **浮点数** 还是 **字符变量** ，所存储的数字都有一个范围。这个 **存储范围** 与存储该类型变量 **所需要的空间** 有关。
2. >由于变量数据存储的 **类型** 取决于 **具体的计算机系统** ，因此我们在编写程序的时候千万 **不要对于数据类型的存储空间** 进行假定。

---

### 1.2.3 浮点数类型float

1. >在表示 **浮点数常量** 时，有时可以 **省略小数点前面或者后面的数字** ，但是不能两者都省略。
2. >如果需要 **在终端上面显示浮点数** ，可以使用格式化输出符号 *%$f$* 。
3. >我们也可以使用 **科学计算法** 表示 **浮点数** 。在科学计算法中，字母 *$e$* 前面的数字是 **尾数** ，*$e$* 后面的数字是 **指数** ，指数是以 *$10$* 为底的，前面可以有 **正号** 或者 **负号** 。
4. >在科学计数法中，用来 **分隔尾数** 和 **指数** 的字母 *$e$* ，**大小写都是合法的** 。
5. >如果需要在终端上使用 **科学计算法** **显示浮点数** ，可以使用格式化输出符号 *%$e$* 。
6. >如果输出浮点数时使用格式化符号 *%$g$* ，那么 *$printf$* 函数就会 **自行决定** 如何显示一个浮点数：如果这个数的 **指数** 小于 *$-4$* 或者大于 *$5$* ， *$printf$* 就会使用 **科学计数法** ，否则将 **使用正常的格式** 。
7. >**十六进制的浮点数** 表达式前面是 *$0X$* 或者 *$0x$* ，后面是 **一个或者多个** 十六进制数字，在后面是字母 *$p$* 或者 *$P$* ，最后是一个可选的 **以 *$2$* 为底的指数** 。

---

### 1.2.4 扩展精度的浮点类型double

1. >*$double$* 类型与 *$float$* 类型非常相似，但是它提供了比 *$float$* 类型 **更高的存储精度** 。一般来说，*$double$* 使用的存储空间是 *$float$* 的 **两倍** 。
2. >除非特别指明， **所有的浮点数常量** 都被 *$C$* 语言当作 *$double$* 类型处理。
3. >为了明确说明一个 *$float$* 类型的浮点常量，我们需要在 **表达式后面** 加上字符 *$f$* 或者 *$F$* 。
4. >显示 *$double$* 类型的变量 **使用的格式化符号** 与 *$float$* 类型相同，即 *%$f$* 、 *%$e$* 或者 *%$g$* 。

---

### 1.2.5 字符类型char

1. >*$char$* 类型的变量用于 **存储单个字符** 。
2. >一个 **字符常量** 由 **一对单引号** 和 **这对单引号括起来的字符** 组成。
3. >注意，字符 *$0$* 和数字 *$0$* 是 **不同** 的，前者是用单引号括起来的 **单个字符** ，后者是用双引号括起来的 **任意多个字符** 。
4. >反斜线 `\n` 是 *$C$* 语言中的 **特殊字符** ，也是一个 **合法的字符常量** 。
5. >如果要 **在终端上显示单个字符** ，可以使用格式化输出符号 *%$c$* 。

---

### 1.2.6 布尔类型_Bool

1. >**布尔类型的变量** 可以用来 **存储** *$0$* 和 *$1$* 。
2. >按照 *$C$* 语言惯例， *$0$* 代表 **假** ， *$1$* 代表 **真** 。当我们给布尔类型的变量 **赋零值** 时，该变量存储 *$0$* ， **赋其他值**的时候，该变量存储 *$1$* 。
3. >由于 **计算机存储精度** 是 **有限** 的，因此会在 **读取浮点数** 的时候造成**误差** 。
4. >*$printf$* 函数提供了 **三种格式化输出符号** ，用于显示浮点数的 **值** 。
5. >*%$f$* 使用 **标准的格式** 显示浮点数。
6. >如果没有特别的指定， *$printf$* 函数在使用 *%$f$* 显示 **浮点数** 时，只显示 *$6$* 位数字。
7. >当使用 *%$g$* **输出** 浮点数时， *$printf$* 函数 **自动选择** 使用标准格式还是科学计算法。
8. >对于 *_$Bool$* 类型的变量，我们可以使用 *%$i$* **显示其内容** 。

---

### 1.2.7 类型修饰符：long, long long, short, unsigned和signed

1. >**声明整型变量** 时， *$int$* 前面如果使用 **整型修饰符** *$long$* ，该变量表示的 **数字范围** 在某些计算机系统上会 **增加** 。
2. >和 *$float$* 、 *$double$* 类型相似，**长整型变量变量** 能够存储的 **数字范围** 依赖于 **具体的计算机系统** 。
3. >在具体的计算机上 **长整型** 和 **普通整型** ，其表示的 **数字范围** 是 **相同** 的，都是 *$32$* 位。
4. >在整型常量表达式后面加上字母 *$i$* ，就代表长整型的 **常量表达式** ，数字和字母 *$i$* 之间 **不能有空格** 。
5. >使用 *$printf$* 函数，显示 **长整型变量** 时，需要在格式化输出符号 *$i$* 、 *$o$* 、 *$x$* 前面加上 **修饰符 *$l$*** 。
6. >*$long long$* 修饰符修饰整型变量时，最少占有 *$64$* 位的 **存储空间** 。
7. >如果要输出 *$long long int$*  类型的变量，需要在 **普通的格式化输出符号** 前面加上两个 *$ll$* ，例如 *%$lli$* 。
8. >在普通的 **浮点数表达式后面** 加上 *$l$* 或者 *$L$* ，就形成了 *$long double$* 类型的常量表达式。
9. >如果要显示 *$long double$* 类型的变量，在 **浮点数格式化输出符号前面** 加上 *$L$* 就可以了。
10. >如果我们在 *$int$* 型变量声明前面加上 *$short$* 修饰符，编译器就假定该变量只是用来 **存放相对较小的整数** 。
11. >什么情况下会使用 *$short$* 修饰符呢？当程序需要 **大量的内存** ，而内存数量又 **相当有限** 时。因为这样做的原因是 **节约内存** 。
12. >在某些计算机系统中， *$short int$* 类型的变量 **占用的存储空间** 是普通 *$int$* 类型变量的一半，但无论如何， *$short int$* 类型变量的存储空间不会少于 *$16$* 位。
13. >*$C$* 语言 **没有提供** *$short int$* 类型的 **常量表达式** 。
14. >如果需要输出 *$short int$* 类型的变量，可以在普通 **整型数的格式化输出符号前面** 放 **一个字母** *$h$* ，如 *%$hi$*   *%$ho$*   *%$hx$* 。实际上我们也可以直接使用 **整型数的格式化输出符号** ： *%$i$* ， *%$o$* 和 *%$x$* 。
15. >当我们需要声明一个 **只存储正数的整型变量** 时，可以使用这个修饰符。
16. >在普通的 **整数常量表达式** 后面放一个字母 *$u$* （或者 *$U$* ），就形成 *$unsigned int$* 类型的常量表达式。
17. >当一个整型常量表达式后面 **没有任何修饰符** *$u$* ， *$U$* ， *$l$* 或者 *$L$* 时， *$C$* 语言就假定它是一个 *$int$* 类型的表达式。如果这个表达式的值 **无法存放** 到普通的 *$int$* 中，编译器就将其作为一个 *$unsigned int$* 处理，如果还是无法存放，就 **依次尝试** *$long int$*  、 *$unsigned long int$*  和 *$long long int$*  和 *$unsigned long long int$* 。
18. >当我们声明 *$long long int$* 、 *$long int$* 、 *$short int$* 或者 *$unsigned int$* 类型的变量时，可以 **省略关键字** *$int$* 。
19. >*$char$* 类型的变量声明前面，也可以使用 *$unsigned$* 修饰符。
20. >*$signed$* 修饰符 **用于明确地通知编译器** ，某个变量是 **有符号** 的。
21. >*$signed$* 修饰符主要用于 *$char$* 类型的 **声明** 。

---

## 1.3 使用算术表达式

1. >在 *$C$* 语言中--实际上几乎所有的编程语言中， **加号** `+` 用于计算两个数的 **和** ，**减号** `-` 用于计算两个数的 **差** ，**星号**（ `*`）用于表示 **两数相乘** ，**斜线** （`/` ）月用于表示 **两数相除** 。
2. >因为这些操作符 **需要两个操作数** ，因此它们被称为 **二元操作符** 。
3. >*$C$* 语言中的每一个操作符都有自己的 **优先级** ，对于包含多个操作数的表达式， *$C$* 语言 **首先处理优先级高的操作符** 。
4. >如果一个表达式中包含 **多个相同优先级的操作符** ，则根据 **具体操作符的不同** ，有可能从左向右求值，也可能从右向左求值，这个特性被称作 **操作符的关联性** 。
5. >在某些计算机系统中，使用 *$0$* 作为 **除数** 会导致 **程序异常退出** 。即使程序 **没有非正常退出** ，使用 *$0$* 作为除数，得出的 **结果也是没有意义** 的。
6. >如果想要改变表达式的 **求值顺序** ，我们可以 **使用括号** 。

### 1.3.1 整数算术和单目减法操作符

1. >迄今为止，在我们所有的程序中，**每个操作符两边都有空格** ，这也是为了使得程序显得 **美观** ， *$C$* 语言本身并不要求这样。
2. >无论什么时候，如果某个运算的两个操作数都是 **整型数** ， *$C$* 语言就会 **使用整数算术的规则** 执行该运算。这种情况下，所有运算的 **小数点部分** 都会 **被丢弃** 。
3. >在编写程序的时候，到底是使用 *$int$* 型的变量还是使用 *$float$* 型的变量，是 **根据程序的实际需要** 决定的。
4. >如果我们 **不需要任何小数结果** ，那么就应该 **使用整型变量** 。
5. >如果我们需要 **精确的结果** ，就应该 **使用浮点数** 。
6. >C语言本身提供了 **三类浮点数** ， *$float$* 、 *$double$* 、 *$long double$* ，具体在程序中使用哪种类型，要根据程序处理的 **计算精度** 和 **数字大小** 决定。
7. >除了 **单目加法操作符** （ `+` ）之外，**单目减法操作符的优先级** 比其他算术操作符的 **优先级都要高** ，而这两个操作符的优先级则是 **相同** 的。

### 1.3.2 余数操作符

1. >在 *$printf$* 函数中， *%* 后面紧跟的一般是 **格式化输出符号** ，用以 **描述如何输出传递给 *$printf$* 函数的其他参数** 。但是，如果 *%* 后面还跟着一个 *%* 的话，它的意思是要求 *$printf$* 真正地输出一个 *%* 。
2. >在 *$C$* 语言的一条语句中任何一个可以 **使用空格的地方** ，我们都可以 **将空格后面的内容写到下一行中** 。（但是在 **字符串中是不可以这样做** 的）在某些情况下， **将一条语句某些部分另起一行书写** ，不仅是可以的，也是必须的。
3. >**两个整数** 之间的任何运算都采用 **整数运算的法则** ，两个数相除所得的 **余数将被舍弃** 。

### 1.3.3 整型数与浮点数之间的转换

1. >在 *$C$* 语言中，如果我们把一个 **浮点数赋给一个整型数** ，浮点数的 **小数部分将被折断** 。
2. >把一个整型变量赋给一个浮点变量 **不会丢失任何精度** ，系统将 **自动对其进行转换** 。
3. >记住哟！无论何时，只要运算式中的 **两个操作数都是整数**（也包括 *$short$* 、 *$unsigned$* 、 *$long$* 、 *$long long$* ），其运算就遵循 **整数运算规则** ：两个数相除时，其 **余数将被丢弃** 。 **即使我们将运算结果保存在一个浮点数中也是这样** 。
4. >在 *$C$* 语言中，如果一个运算的两个操作数中有一个是 **浮点数** ，不论是浮点常数还是浮点变量，这个运算都被看作是 **浮点运算** 。
5. >**类型转换操作符** 使得 *$C$* 语言在对表达式求值的时候，临时将一个浮点型变量看作一个整型变量。这个操作符并 **不会影响这个变量实际存放的值** 。
6. >除了 **单目加法** 和 **单目减法操作符** 之外，类型转换操作符的 **优先级高于** 其他任何 **算术操作符** 。
7. >我们总是可以 **使用括号** 控制表达式的 **求值过程** ，使其 **按照我们需要的顺序进行** 。

---

## 1.4 结合运算和赋值：运算赋值操作符

1. >在 *$C$* 语言中，我们可以使用格式 “ `op=` ” 将 **赋值操作** 和 **运算操作** 结合起来。
2. >在这个格式中， *$op$* 代表 **任何算术操作符** ，包括 *$+$* 、 *$-$* *和 % 。另外，*$op$* 也可以是我们后面将要讨论的 **位操作符** 。
3. >**加等操作符**（+=）的作用是 **将其左面的操作数** 和 **右面的操作数加起来** ，然后 **将其结果存放在左面的操作数中** 。
4. >使用 **运算操作符** 的主要原因有三个：第一，这种写法可以 **简化程序** ，因为我们 **不必** 在操作符右面再次书写左面的操作数符号；第二，这样的写法 **可读性较好** ；第三，使用这种操作符编写的程序某些情况下，**执行将会更快一些** ，因为编译器生成的 **用于求值的指令较少** 。

---

## 1.5 类型_Complex和_Imagiary

1. >用于处理 **复数** 的数据类型： *$_Complex$* 。
2. >用于处理 **虚数** 的数据类型： *$_Imaginary$* 。

---
