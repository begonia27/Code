# 第十章 字符串

- [第十章 字符串](#第十章-字符串)
  - [1.1 字符数组](#11-字符数组)
    - [1.2 可变长度的字符串](#12-可变长度的字符串)
    - [1.2.1 字符串的初始化和显示](#121-字符串的初始化和显示)
    - [1.2.2 检验字符串相等](#122-检验字符串相等)
    - [1.2.3 输入字符串](#123-输入字符串)
    - [1.2.4 单字符输入](#124-单字符输入)
    - [1.2.5 空字符串](#125-空字符串)
  - [1.3 转义字符](#13-转义字符)
  - [1.4 关于字符串常量的进一步讨论](#14-关于字符串常量的进一步讨论)
  - [1.5 字符串、结构与数组](#15-字符串结构与数组)
    - [1.5.1 一个更好的搜索算法](#151-一个更好的搜索算法)
  - [1.6 字符运算](#16-字符运算)

---

* [1.2 可变长度的字符串](#12-可变长度的字符串)

  * [1.2.1 字符串的初始化和显示](#121-字符串的初始化和显示)

  * [1.2.2 检验字符串相等](#122-检验字符串相等)

  * [1.2.3 输入字符串](#123-输入字符串)

  * [1.2.4 单字符输入](#124-单字符输入)

  * [1.2.5 空字符串](#125-空字符串)

---

* [1.3 转义字符](#13-转义字符)

---

* [1.4 关于字符串常量的进一步讨论](#14-关于字符串常量的进一步讨论)

---

* [1.5 字符串、结构与数组](#15-字符串、结构与数组)

  * [1.5.1 一个更好的搜索算法](#151-一个更好的搜索算法)

---

* [1.6 字符运算](#16-字符运算)

---

## 1.1 字符数组

1. >字符串一般用 **双引号** 包围起来，在双引号中我们可以任意使用 **字母** 、 **数字** 或 **特殊字符** ，也可以 **包含双引号** 。
2. >如果要把某个 **字符** 赋给 **字符常量** ，字符必须使用 **单引号** 括起来。
3. >单引号和双引号仅仅是表达了 *$C$* 语言中的了 **两种不同的常量** 。
4. >如果我们想 **保存多个字符** ，应该使用 **字符数组** 。
5. >为了 **打印** 字符数组的内容，我们可以 **循环遍历** 数组的每一个元素。
6. >传递给函数的字符数组要有 **足够的空间** ，否则，程序运行将会产生 **不可预料** 的结果。

---

### 1.2 可变长度的字符串

1. >**自动处理字符** 的数组，可以使得编程人员 **不需要** 逐个记住每个字符数组中到底存放着 **多少字符** 。
2. >自动处理字符方法的 **核心思想** 是：在每一个字符串的 **结尾存放** 一个 **特殊的字符** 。利用这个办法，函数在 **扫描字符串** 的时候，如果遇到这个特殊字符，就知道自己已经到达了字符串的 **结尾** 。
3. >如果开发的字符串函数处理的全都是这个类型的字符串，那么在调用函数的时候就不必指定字符串的长度了。
4. >在 *$C$* 语言中，用于指定字符串结束的特殊字符是 *$null$* ，或则会称为空字符，它的表达式是 *$'\0'$* 。
5. >例如：*$const char word[] = {'H', 'e', 'l', 'l', 'o', '!', '\0'};$* 是定义了一个包含 *$7$* 个字符的字符数组，这个字符数组的 **最后一个字符** 就是 **空字符** 。
6. >\ 在*$C$* 语言中是一个特殊的字符，当它单独出现在表达式中的时候，并不被当做一个字符，因此，'\0'实际上代表了一个字符。
7. >对于一个 **以空字符串结尾的字符数组** ，我们定义它的长度为：**除了结尾空字符以外所有的字符个数** 。
8. >如果我们定义的是上述例子 *$const char word[] = {'H', 'e', 'l', 'l', 'o', '!', '\0'};$* 中的字符数组，那么字符长度函数调用的 **返回值** 应该是 **3** 。

---

### 1.2.1 字符串的初始化和显示

1. >在初始化字符数组的时候，C语言允许使用单个的常量字符串表达式，而不是一组单个的字符。
2. >在printf函数中，我们可以使用格式描述字符%s来显式空字符结尾的字符串。
3. >虽然一个数组定义了众多个字符的数量，但是printf函数仅仅显式到空字符为止。

---

### 1.2.2 检验字符串相等

1. >C语言不允许我们使用==操作符来检验两个字符串是否相等。
2. >因为==操作符只能用于简单的变量类型，例如float, int, char, 而不能用于负责的数据类型，例如结构或者数组。
3. >为了检验两个字符串是否相等，我们必须逐个比较这两个字符串的所有字符。
4. >如果在比较的过程中，我们同时到达了两个字符串的结尾，而且在此之前比较的所有字符都相同，那么这两个字符串才是相等的，否则它们不相等。
5. >由于我们只关心两个字符串是否相等，因此我们可以让函数的返回值是布尔类型。当两个字符串相等的时候，返回true；当它们不相等的时候，返回false。

---

### 1.2.3 输入字符串

1. >在C语言中，我们可以使用若干个库函数来帮助我们从终端上读入一个字符串。
2. >如果使用scanf函数，并使用格式化输入符号%s，那么该函数将从终端上读入一个字符串，直到遇到空格、制表符或者换行符中的任何一个为止。
3. >当把字符数组作为参数传递给函数的时候，我们不需要在变量名前面加上&符号。
4. >函数在读入的时候如果遇到空白、Tab或者换行符，就会停止读取。此时，如果在程序中再次调用scanf函数，那么剩下的字符串将被继续读取。
5. >如果用户在终端上连续输入80个以上的字符，并在在其中不加入空格、Tab或者换行符的话，scanf读取的内容将超过字符数组的容量。这有可能导致程序意外终止，或者发生不可意料的行为。
6. >如果我们在格式化符号%s的百分号后面放置一个数字的话，这个数字就用于告诉scanf函数，我们能够读取的字符的最大数量。

---

### 1.2.4 单字符输入

1. >在C语言的标准库中的getchar函数中，可以从终端读取一个字符，然后多次调用这个函数，；如果读入到达了一行的末尾，该函数则返回换行符'\n'。
2. >使用getchar函数的好处在于设计该函数的唯一目的就是读取单个字符，因此使用该函数比较方便，因为我们不需要传递任何参数给它，
3. >在很多文字处理方面的应用中，我们常常需要一次读入一行文字，然后将其保存在某个缓冲区中，以便随后对其进行处理。使用scanf函数和格式化输入符号%s并不能完成这件工作，因为scanf函数在遇到空白的时候就会停止读取（而一行文本中通常都会有空白字符）。

---

### 1.2.5 空字符串

1. >为了使得程序更加灵活，我们将不限制用户输入的行数。因此，我们需要找到一种方式，用于通知程序用户已经完成了输入。
2. >当用户输入最后一行文字以后，再额外多输入一个空行，这样，函数在读取这个额外的空行的时候，程序将在用作缓冲区的数组的第一个位置存储一个空字符。我们程序可以专门检查这种特殊的情况，并由此得知用户已经完成了输入。
3. >一个只包含空字符的字符串在C语言中有一个专门的名称：空字符串（null字符串）。
4. >我们需要记住这个事实：空字符串中也是有一个字符的，只不过它是空字符。
5. >有些时候，我们需要将程序中的某些字符串设置为空字符串，在C语言中，空字符串用两个相连的双引号表示。
6. >务必要注意的是：空字符串""和字符串" "是不同的，后者并不是空字符串，其中包含一个空格。
7. >如果某位坐着使用计算机来输入其作品，并将作品保存为磁盘文件，那么使用程序可以很方便的统计出手稿中单词的数量。（手稿必须是普通的文本文件，而不是专有的格式：比如Microsoft Word）。

---

## 1.3 转义字符

---

## 1.4 关于字符串常量的进一步讨论

---

## 1.5 字符串、结构与数组

### 1.5.1 一个更好的搜索算法

---

## 1.6 字符运算

---
