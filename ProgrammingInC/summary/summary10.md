# 第十章 字符串

- [第十章 字符串](#第十章-字符串)
  - [1.1 字符数组](#11-字符数组)
    - [1.2 可变长度的字符串](#12-可变长度的字符串)
    - [1.2.1 字符串的初始化和显示](#121-字符串的初始化和显示)
    - [1.2.2 检验字符串相等](#122-检验字符串相等)
    - [1.2.3 输入字符串](#123-输入字符串)
    - [1.2.4 单字符输入](#124-单字符输入)
    - [1.2.5 空字符串](#125-空字符串)
  - [1.3 转义字符](#13-转义字符)
  - [1.4 关于字符串常量的进一步讨论](#14-关于字符串常量的进一步讨论)
  - [1.5 字符串、结构与数组](#15-字符串结构与数组)
    - [1.5.1 一个更好的搜索算法](#151-一个更好的搜索算法)
  - [1.6 字符运算](#16-字符运算)

---

* [1.2 可变长度的字符串](#12-可变长度的字符串)

  * [1.2.1 字符串的初始化和显示](#121-字符串的初始化和显示)

  * [1.2.2 检验字符串相等](#122-检验字符串相等)

  * [1.2.3 输入字符串](#123-输入字符串)

  * [1.2.4 单字符输入](#124-单字符输入)

  * [1.2.5 空字符串](#125-空字符串)

---

* [1.3 转义字符](#13-转义字符)

---

* [1.4 关于字符串常量的进一步讨论](#14-关于字符串常量的进一步讨论)

---

* [1.5 字符串、结构与数组](#15-字符串、结构与数组)

  * [1.5.1 一个更好的搜索算法](#151-一个更好的搜索算法)

---

* [1.6 字符运算](#16-字符运算)

---

## 1.1 字符数组

1. >字符串一般用 **双引号** 包围起来，在双引号中我们可以任意使用 **字母** 、 **数字** 或 **特殊字符** ，也可以 **包含双引号** 。
2. >如果要把某个 **字符** 赋给 **字符常量** ，字符必须使用 **单引号** 括起来。
3. >单引号和双引号仅仅是表达了 *$C$* 语言中的了 **两种不同的常量** 。
4. >如果我们想 **保存多个字符** ，应该使用 **字符数组** 。
5. >为了 **打印** 字符数组的内容，我们可以 **循环遍历** 数组的每一个元素。
6. >传递给函数的字符数组要有 **足够的空间** ，否则，程序运行将会产生 **不可预料** 的结果。

---

### 1.2 可变长度的字符串

1. >**自动处理字符** 的数组，可以使得编程人员 **不需要** 逐个记住每个字符数组中到底存放着 **多少字符** 。
2. >自动处理字符方法的 **核心思想** 是：在每一个字符串的 **结尾存放** 一个 **特殊的字符** 。利用这个办法，函数在 **扫描字符串** 的时候，如果遇到这个特殊字符，就知道自己已经到达了字符串的 **结尾** 。
3. >如果开发的字符串函数处理的全都是这个类型的字符串，那么在调用函数的时候就不必指定字符串的长度了。
4. >在 *$C$* 语言中，用于指定字符串结束的特殊字符是 *$null$* ，或则会称为空字符，它的表达式是 *$'\0'$* 。
5. >例如：*$const char word[] = {'H', 'e', 'l', 'l', 'o', '!', '\0'};$* 是定义了一个包含 *$7$* 个字符的字符数组，这个字符数组的 **最后一个字符** 就是 **空字符** 。
6. >\ 在*$C$* 语言中是一个特殊的字符，当它单独出现在表达式中的时候，并不被当做一个字符，因此，'\0'实际上代表了一个字符。
7. >对于一个 **以空字符串结尾的字符数组** ，我们定义它的长度为：**除了结尾空字符以外所有的字符个数** 。
8. >如果我们定义的是上述例子 *$const char word[] = {'H', 'e', 'l', 'l', 'o', '!', '\0'};$* 中的字符数组，那么字符长度函数调用的 **返回值** 应该是 **3** 。

---

### 1.2.1 字符串的初始化和显示

1. >在 **初始化** 字符数组的时候，*$C$* 语言允许使用单个的 **常量字符串表达式** ，而不是一组单个的字符。
2. >在 *$printf$* 函数中，我们可以使用 **格式描述字符** **%s** 来显示 **空字符结尾** 的字符串。
3. >虽然一个数组定义了 **众多个字符的数量** ，但是 *$printf$* 函数仅仅显示到 **空字符** 为止。

---

### 1.2.2 检验字符串相等

1. >*$C$* 语言 **不允许** 我们使用 **==操作符** 来检验两个字符串是否相等。
2. >因为==操作符只能用于 **简单的变量类型** ，例如 *$float$* ， *$int$* ， *$char$*， 而不能用于复杂的数据类型，例如 **结构** 或者 **数组** 。
3. >为了检验两个字符串是否相等，我们必须 **逐个比较** 这两个字符串的 **所有字符** 。
4. >如果在比较的过程中，我们 **同时到达** 了两个字符串的 **结尾** ，而且在此之前比较的 **所有字符都相同** ，那么这两个字符串才是相等的，否则它们不相等。
5. >由于我们只关心两个字符串 **是否相等** ，因此我们可以让函数的 **返回值是布尔类型** 。当两个字符串相等的时候，返回 *$true$* ；当它们不相等的时候，返回 *$false$* 。

---

### 1.2.3 输入字符串

1. >在 *$C$* 语言中，我们可以使用 **若干个库函数** 来帮助我们 **从终端上读入一个字符串** 。
2. >如果使用 *$scanf$* 函数，并使用格式化输入符号 **%s** ，那么该函数将从终端上读入一个字符串，直到遇到 **空格** 、 **制表符** 或者 **换行符** 中的任何一个为止。
3. >当把 **字符数组** 作为 **参数传递** 给函数的时候，我们 **不需要** 在变量名前面加上 *$&$* 符号。
4. >函数在读入的时候如果遇到 **空白** 、 *$Tab$* 或者 **换行符** ，就会 **停止读取** 。此时，如果在程序中再次调用 *$scanf$* 函数，那么剩下的字符串将被继续读取。
5. >如果用户在终端上连续输入 *$80$* 个以上的字符，并在在其中不加入空格、Tab或者换行符的话，*$scanf$* 读取的内容将 **超过** 字符数组的容量。这有可能导致 **程序意外终止** ，或者**发生不可意料的行为** 。
6. >如果我们在格式化符号 **%s** 的百分号后面放置一个 **数字** 的话，这个数字就用于告诉 *$scanf$* 函数，我们能够读取的字符的 **最大数量** 。

---

### 1.2.4 单字符输入

1. >在 *$C$* 语言的标准库中的 *$getchar$* 函数中，可以 **从终端读取一个字符** ，然后 **多次调用** 这个函数， 如果读入到达了一行的末尾，该函数则 **返回换行符'\n'** 。
2. >使用 *$getchar$* 函数的好处在于设计该函数的唯一目的就是 **读取单个字符** ，因此使用该函数比较方便，因为我们 **不需要传递任何参数** 给它。
3. >在很多文字处理方面的应用中，我们常常需要 **一次读入一行文字** ，然后将其保存在某个 **缓冲区** 中，以便随后对其进行处理。使用 *$scanf$* 函数和格式化输入符号 **%s** 并不能完成这件工作，因为 *$scanf$* 函数在遇到 **空白** 的时候就会停止读取（而一行文本中通常都会有空白字符）。

---

### 1.2.5 空字符串

1. >为了使得程序更加 **灵活** ，我们将 **不限制** 用户输入的 **行数** 。因此，我们需要找到一种方式，用于 **通知程序** 用户已经 **完成了输入** 。
2. >当用户输入 **最后一行文字** 以后，再 **额外多输入** 一个空行，这样，函数在读取这个额外的空行的时候，程序将 **在用作缓冲区的数组的第一个位置存储一个空字符** 。我们程序可以专门检查这种 **特殊的情况** ，并由此得知用户已经完成了输入。
3. >一个 **只包含空字符** 的字符串在 *$C$* 语言中有一个专门的名称：**空字符串** （*$null$* 字符串）。
4. >我们需要记住这个事实：空字符串中也是有 **一个字符** 的，只不过它是 **空字符** 。
5. >有些时候，我们需要将程序中的某些字符串设置为 **空字符串** ，在 *$C$* 语言中，空字符串用 **两个相连的双引号** 表示。
6. >务必要注意的是：空字符串 **""** 和字符串 **" "** 是不同的，后者并不是空字符串，其中 **包含一个空格** 。
7. >如果某位作者使用计算机来输入其作品，并将作品保存为 **磁盘文件** ，那么使用程序可以很方便的统计出手稿中 **单词的数量** 。（手稿必须是普通的 **文本文件** ，而不是专有的格式：比如 *$Microsoft Word$* ）。

---

## 1.3 转义字符

1. >*$C$* 语言中的 **转义字符** ：

   |转义字符    |字符名
   |----      |---
   |\a        |警铃
   |\b        |退格
   |\f        |表单输入
   |\n        |换行
   |\r        |回车
   |\t        |水平制表
   |\v        |垂直制表
   |\\\        |反斜线
   | \"       |双引号
   | \'       |单引号
   | \?       |问号
   |\nnn      |八进制数nnn代表的字符
   |\unnnn    |通用字符名
   |\Unnnn    |通用字符名
   |\xnn      |十六进制数nn代表的字符

2. >如果一个字符串包含回退字符 **'\b'** ，那么当我们使用 *$printf$* 语句输出该字符串的时候，计算机在遇到 **'\b'** 时，将会删除上一个输出的字符。
3. >制表符 **'\t'** ，用于将 **随后的输出** 移到下一个 **制表符** 的位置。
4. >制表符在对于 **对齐按列输出** 的数据时很有用处。
5. >在字符串 **"pritnf{\\t is the horizontal tab character.\n}";**  中，*$C$* 语言编译器首先输出的是一个 **反斜线字符** 和字母 *$t$* ，而不是反斜线和一个制表符。
6. >如果我们要在字符串中包含一个 *$ASCII$* 的 *$ESC$* 字符，因为这个字符的编码是 *$33$* ，因此我们可以使用转义字符 **\033** 或 **x1b** 。
7. >对于前面所说的 **转义字符编码规则** 来说，空字符 **'\0'** 是一个例外，该字符表示值为 *$0$* 的字符。
8. >由于在 *$C$* 语言中空字符的值为 *$0$* ，因此程序员们常常使用这一点来 **简化** 处理字符串的程序。
9. >通用字符名由 **反斜线** 、小写字符 *$u$* 后面跟上 *$4$* 个 **十六进制数** 或者大写字符 *$U$* 后面跟上 *$8$* 个 **十六进制数字** 构成。这些转义字符用于表示 **扩展字符集** 中的字符，这些字符的 **编码长度** 超过了标准的 *$8$* 位 **二进制数** 所能表示的范围。
10. >**通用字符名** 可以用于表示 *$16$* 位或者 *$32$* 位的字符。

---

## 1.4 关于字符串常量的进一步讨论

1. >如果我们在一行代码的 **行尾** 放置一个 **反斜线** ，*$C$* 语言编译器将会 **忽略** 行尾的换行符，而把下一行的内容也算作的本行的内容。
2. >如果 **不使用** 反斜线，当我们试图初始化一个 **跨多行** 的字符串时，*$C$* 语言编译器就会发出警告。
3. >*$C$* 语言中还有一种 **拆分长字符串** 的方法，那就是将其写成 *多个相邻的字符串** 。这些字符串之间用 *$0$* 个、多个 **空白** 、 **制表符** 或者 **换行符** 隔开。编译器在编译源代码的时候，会 **自动** 将这些字符串 **连接** 起来。

---

## 1.5 字符串、结构与数组

1. >假定我们要编写一个 **字典程序** ，我们可以使用该程序来 **查询** 那些我们 **不太明白的单词** ，比如，当我们启动字典程序，然后输入该单词，随后该程序就会自动地在字典中查找该单词的解释。
2. >编写这个字典程序需要解决的第一个问题就是 **如何在计算机中表示某个单词以及其对应的解释** 。很明显，因为一个单词和它的解释在 **逻辑概念** 上是关联的，因此我们很容易想到使用 **结构** 来处理它们。
3. >语句 *$“struct entry dictionary[100];”$* 这个语句定义了一个能够容纳 *$100$* 个单词及其解释的 **结构数组** 。
4. >很明显， *$100$* 个单词的 **数目** 对于任何有价值的英文字典来说都是 **远远不足** 的，因此，对于实际的英文字典来说，我们通常会 **把内容保存在计算机的磁盘上** ，而 **不是内存中** 。
5. >在定义完字典词条之后，我们还需要考虑一个所有词条的 **组织问题** 。绝大多数字典的词条都是 **按照字母顺序排序** 的。这种做法对于我们的字典也是合适的。
6. >在实际编写程序的过程中，我们需要 **先定义一个函数** ，用于在字典中查找单词。如果找到了单词的解释，该函数就返回这个单词在字典对应词条的 **下标号码** ，如果没有的话，该函数就返回 *$-1$* 。

---

### 1.5.1 一个更好的搜索算法

1. >对于一个较小的字典，使用总结 *$1.5$* 中所描述的方法是完全合适的，但是对于那些有着成百上千词条的字典，这种 **遍历所有词条的方法** 就显得 **效率不高** 了。
2. >虽然在现代的计算机上，遍历这么大的结构数组可能只意味着几分之一秒，但是 **对于任何信息查找类型的应用** 来讲，**检索速度** 都是一个至关重要的指标。因为在 **应用程序** 中信息查找的 **使用频率** 非常之高，因为人们花费了大量的时间和精力来寻找 **更加有效的搜索算法** 。
3. >使用 **二分查找法** ，可以帮助我们的程序 **提高查找速度** 。
4. >**二分搜索法** ：

```C
      1. 设置变量low = 0，high = n - 1。
      2. 如果low > high，那么x不在数组M中，算法结束。
      3. 设置变量mid = （low + high）/ 2；
      4. 如果M[mid] < x ，设置 low = mid + 1，回到步骤2。
      5. 如果M[mid] > x ，设置 high = low - 1，回到步骤2。
      6. 如果M[mid] = x ，那么我们已经找到该元素，算法结束。
      7. （注意，在第三步中，除法是一个整数除法，也就是说，如果low等于0，而high等于49，那么mid就等于24。）
```

---

## 1.6 字符运算

1. >*$C$* 语言经常在 **关系表达式** 和 **算术表达式** 中用到 **字符类型的变量** 或者 **常量** 。
2. >为了能够正确地 **运用字符类型** ，读者需要了解一下 *$C$* **语言编译器** 处理 **字符类型变量** 或者 **常量** 的方式。
3. >无论什么时候，我们在表达式中用到了字符类型的常量或者变量，*$C$* 语言编译器都将其当做一个 **整型数值** 来处理。
4. >在表达式 *$“c >= 'a' 或者 c <= 'z'”$* 中，该表达式可以 **判断字符变量 *$c$* 的值是否是一个小写字母** 。
5. >在 *$ASCII$* 编码中，*$'a'$* 的值是 *$97$* ，*$'b'$* 的值是 *$98$* ，其他小写字母值 **依次类推** 。因为 *$ASCII$* 编译的值大于 *$97$* 的字符 **不全是** 小写字母，因此为了 **准确判断字符变量** 的 *$C$* 是不是 **小写字母** ，还需要对 **上限** 进行判断。
6. >虽然给某个字符型变量的值加 *$1$* 看上去不是很实用，实际上我们可以使用这套技术在字符 *$'0'$* 到 *$'9'$* 之间方便的 **进行转换** 。
7. >假定变量 *$C$* 包含字符 *$'5'$* ，这个字符的 *$ASCII$* 编码值是 *$53$* ，那么式子 *$“i = c - '0'”$* 就可以计算出 *$c$* 所对应的 **编码值** 。

---
