# 第八章 使用函数

* [1.1 定义函数](#11-定义函数)

---

* [1.2 参数与局部变量](#12-参数与局部变量)

  * [1.2.1 函数原型声明](#121-函数原型声明)

  * [1.2.2 自动局部变量](#122-自动局部变量)

---

* [1.3 函数的返回值](#13-函数的返回值)

---

* [1.4 函数的调用](#14-函数的调用)

  * [1.4.1 声明返回值类型以及参数类型](#141-声明返回值类型以及参数类型)

  * [1.4.2 检查函数的参数](#142-检查函数的参数)

---

* [1.5 自顶向下的程序设计](#15-自顶向下的程序设计)

---

* [1.6 函数与数组](#16-函数与数组)

  * [1.6.1 赋值表达式](#161-赋值表达式)

  * [1.6.2 数组排序](#162-数组排序)

  * [1.6.3 多维数组](#163-多维数组)

  * [1.6.4 函数与可变长度的多维数组](#164-函数与可变长度的多维数组)

---

* [1.7 全局变量](#17-全局变量)

---

* [1.8 自动变量与静态变量](#18-自动变量与静态变量)

---

* [1.9 递归函数](#19-递归函数)

---

## 1.1 定义函数

1. >一个函数定义的第一行（按照从左到有的顺序）告诉编译器四件事情：1.谁能够调用这个函数；2.函数返回值的类型；3.函数的名字；4.函数的参数。
2. >与变量的选择类似，给函数选择一个有意义的名字是非常重要的。名字的选择往往大大地影响程序的可读性。
3. >C语言程序的执行总是从main开始。
4. >函数名称后面的一对小括号告诉编译器，这个名字代表一个函数，在调用函数的时候，我们没有给函数传递任何参数。当计算机执行函数调用的时候，程序的流程将跳转到该函数。
5. >在打印出程序内的消息之后，函数的执行就结束了。程序的执行流程重新回到了main函数中调用函数的地方。
6. >在函数的最后可以增加一条语句： *$return;$* 因为函数被定义为不返回任何值，所以这个 *$return;$* 语句后面没有数值。
7. >在不返回值的函数中，这个 *$return;$* 语句是可有可无的。
8. >printf和scanf函数也都是函数。它们与其他自定义的函数的主要区别在于，printf和scanf函数是标准库的一部分，我们不需要动手去编写它。
9. >无论是调用标准库的函数，还是调用自己编写的函数，在函数调用返回之后，计算机都接着执行调用函数那条语句后面的语句。

---

## 1.2 参数与局部变量

1. >在调用函数的时候，我们总是向函数传递了若干个值，第一个通常是格式化字符串，后面的值则是需要显示的程序计算结果，这些值在C语言中被称为函数参数。
2. >使用函数的参数可以大大增加函数的灵活性。
3. >我们可以自定义接收参数的函数。

---

### 1.2.1 函数原型声明

1. >在函数 *$void calculateTriangularNumber (int n)$* 中,这行语句被称为函数原型声明。它的作用是告诉编译器， *$calculateTriangularNumber$* 是一个函数。该函数不返回任何值（用关键字void标明），函数参数的正式名字是形式参数。
2. >形式参数的名字可以是任何C语言合法的变量名，在编写程序的名字时，应该给形式参数尽可能起一个有意义的名字。
3. >一旦定义了一个形式参数，就可以在函数体的任何地方引用这个形式参数。
4. >函数原型声明下面的左大括号表示函数体正式开始，同样，我们还需要定义一个变量用作循环下标。
5. >这些变量的初始化方法和使用方法与以前在main函数中的使用方法相同。

---

### 1.2.2 自动局部变量

1. >在函数体内部的变量通常被称为自动局部变量。
2. >被称为自动局部变量是因为每次当函数被调用的时候，编译器自动创建这些变量，而且除了函数之外，程序的其他部分无法访问这些变量。
3. >如果在函数中声明变量的时候给期间赋予了初值，那么每次调用该函数的时候，该变量都会重新赋予该初值。
4. >从更规范一些的角度来讲，每次在函数体内定义变量的时候，都应该使用auto这个关键字。因为c语言编译器默认任何在函数体内部定义的变量都是自动局部变量，所以在编程实践中，我们通常省略auto这个关键字。

---

## 1.3 函数的返回值

1. >很多时候，我们并不想显示计算的结果，为此，C语言提供了一种方便的机制--函数的返回值，利用这种机制，一个函数可以将某个值返回给它的调用者。
2. >在函数中返回一个值通常采用如下的语法形式：return 表达式；这个语句将表达式的值返回给函数的调用者。
3. >有些程序员习惯在表达式的周围加上小括号，这属于个人风格，这些小括号本身并不是必须的。
4. >如果要从一个函数中返回一个值，仅仅使用return语句本身还不够，还需要在声明函数的时候声明函数的返回值类型。这个声明应该放在函数名之前。
5. >所有的main函数名前面都有一个关键字int。
6. >我们不一定必须把函数的返回值保存在某个变量中，在main函数中，我们也可以把函数的返回值直接传递给printf函数，然后printf函数再将其结果显示出来。
7. >C语言的函数只能够返回一个值。
8. >不像其他的编程语言，C语言对于函数和过程并不区分，C语言中只有函数，每个函数可以返回一个值，或者不返回值。
9. >如果我们在声明函数的时候不指定函数的返回值类型，那么编译器就假定该函数返回一个整型数--如果这个函数最终返回值的话。
10. >我们应该尽力避免省略对于函数返回值类型的声明，这是一种不好的编程习惯，应该尽力避免。
11. >在函数的声明语句中，我们在函数名前面加上了关键字void，随后如果我们像下面这条语句那样使用该函数，编译器就会报告错误信息：number = calcuteTriangularNumber(20);从某种意义是上来讲，void类型就是没有数据类型，因此如果一个函数声明其返回值是void类型，就是说该函数并不返回值，因此不能用在表达式中。
12. >当我们在函数中改变形式参数的值的时候，绝对不会影响到变量的值。实际上，当我们把变量的值作为参数传递给函数的时候，系统会自动将该变量的值拷贝到形式参数中。随后，在函数之中对于形式参数的任何修改，都不会影响到变量。也就是说，一个函数永远无法修改它的参数的值，它只能修改这些参数的拷贝。
13. >我们传递给函数的参数应该和函数声明的参数类型一致。
14. >如果我们没有在程序中使用类型转换操作符将整型变量转换为浮点型的变量，那么编译器会自动进行转换（编译器根据函数的声明已经得知函数需要的参数类型）。当然，我们也可以手动进行类似的转换，而不是依赖系统完成这些工作，这样可以使得程序显得更清楚一些。
15. >编译器在对函数的返回值进行处理的时候，依然使用我们前面讨论过的算术表达式求值规则。若函数的返回的值是一个浮点数时，编译器将除法表达式看作是一个浮点数除以一个整型数。由于除法操作数之一是一个浮点数，因此整个除法操作数都是用浮点算术规则。

---

## 1.4 函数的调用

1. >在书中示例8.8中，函数absoluteValue和函数squareRoot的形式参数的名字都是x,C语言编译器会自动区分它们，而不会产生混乱。
2. >实际上，每个函数都有自己的形式参数，因此函数absoluteValue和函数squareRoot的形式参数是完全不同的。
3. >在多个函数内，我们可以任意声明多个同名的变量。
4. >由于一个函数内定义的变量，也就是局部变量，只能在那个函数内部被访问，因此C语言编译器不会把它们搞混。也就是说，函数内部定义的变量，其作用域范围就是该函数。

---

### 1.4.1 声明返回值类型以及参数类型

1. >C语言的编译器在遇到函数调用的时候，将假定函数的返回值是整型数，除非遇到 以下两种情况：一个是在函数调用语句之前，编译器已经“看到了”该函数的具体定义；另一个是在函数的调用语句之前，编译器已经“看到了”该函数的声明。
2. >函数的原型声明不但可以告诉编译器函数的返回值类型，还包括函数需要的参数个数以及它们的数据类型。
3. >在声明函数原型的时候，我们可以只给出函数参数的类型而不必指定其名字，我们也可以在函数声明的时候给出参数的“哑”变量名，这个名字不必和函数 定义时使用的参数名称相同，编译器将忽略这里给出的名字。
4. >为了防止拼写错误，我们可以简单地将函数定义过得第一行拷贝作为函数的声明，另外读者需要记住在函数声明的后面有一个分号。
5. >如果函数不需要任何参数，我们可以在函数参数括号之间使用关键字void。我们也需要在声明的时候指出这一点，以防止编译器将函数用于表达式中。
6. >如果函数接收不定数目的参数（比如printf函数和scanf函数），我们可以用下面的方式通知编译器：int printf(char* format,\cdot\cdot\cdot);
7. >在int printf(char* format,\cdot\cdot\cdot);这个声明中，它告诉了编译器，printf函数的第一个参数是字符型指针。在这个参数后还可以有任意多个参数（用\cdot\cdot\cdot）说明。
8. >文件stdio.h中包含了printf函数和scanf函数的原型声明，这也是我们为什么要在我们源文件开始放上如下代码：*$#include <stdio.h>$* 的原因。
9. >如果在程序的一开始没有这些声明，编译器将假定printf函数和scanf函数接收固定多个参数，并生成不正确的可执行代码。
10. >编译器只有在已经看到了函数的定义或者函数原型的情况下，才能在函数调用的时候进行适当的类型转换，因此函数的声明是非常重要的。

---

### 1.4.2 检查函数的参数

1. >如果程序的循环结束条件永远都不会满足，程序将进入一个无限循环的局面，那么为了结束程序，我们必须在终端上按下某些特殊的键（比如ctrl+C)。
2. >C语言的标准库函数sqrt在接收一个负数参数时，将返回错误值domain error。这个符号的具体值是“和”实现相关的，在某些系统中，如果我们试图显示这个数字，将得到结果nan，这个意思是不是一个数字（not a number）。
3. >在单个的函数中可以有多个return语句，当程序遇到return语句的时候，控制流程将会立刻回到调用者，return语句后面的所有语句都不再被执行了。
4. >对于那些不返回任何值的函数来说，return语句的这种用法非常方便，只要采用return;的简单形式就可以达到效果。
5. >对于需要返回某个值的函数来说，就不能使用这种形式return语句了。

---

## 1.5 自顶向下的程序设计

1. >一个函数可以调用另外一个函数，被调用的函数还可以调用其他的函数，依次下去，最终我们就得到一个结构良好的程序骨架。
2. >当我们开始编写一个函数的时候，还可以应用这种自顶向下的设计方法：我们可以声明一个函数并调用它，不需要操心这个函数的实现细节；在编写这个函数的时候，我们只需要确信将来能够书写函数，用它来解决实际的需要。
3. >这种自顶向下的程序设计的方法，不仅能帮助我们更容易地开发某个程序，也能够增加程序的可读性。比如：一个程序员阅读计算平方根的代码时，他并不需要仔细地阅读计算平方根的算法实现细节，就很容易知道这个程序计算了三个数字的平方根并将其显示出来，如果该程序员想要了解该程序的更多细节，就很容易知道这个程度计算了三个数组的平方根并将其显示出来。如果该程序员想要了解该程序的更多细节，他可以更仔细的阅读该函数中的代码。由于这些细节都被封装起来了，只有在必要的时候，才会被进一步研究。

---

## 1.6 函数与数组

1. >如同普通变量一样，在C语言中我们也能够将数组元素甚至是整个数组作为参数传递给函数。
2. >如果要将单个数组元素作为参数传递给某个函数，我们只要使用普通的数组元素表达式就可以了。
3. >函数中包含数组的示例：如果我们要计算数组元素averages[i]的平方根，并将结果保存在变量sq_root_result中，可以使用如下的语句：sq_root_result = squareRoot(averages[i])；在函数squareRoot的内部，我们不需要针对数组元素采用任何特殊的措施。如同普通的变量一样，该数组元素的值被拷贝到形式参数中，然后在函数中正常使用。
4. >将整个数组作为参数传递给函数与传递给单个变量或数组元素完全不同。如果我们要把一个数组传递给某个函数，需要在参数调用的位置写上数组的名字，不需要添加任何下标表达式。例如:gradeScores是一个长度为100的数组，如果我们要把这个数组作为参数传递给minmum函数，可以使用下面的表达式，minimum(gradeScores);另一方面，如果我们要声明参数为数组的函数，可以采用下面的形式：

```C
    int minimum(int values[100])
    {
      \cdot\cdot\cdot
      return minValue;
    }
```

1. >为了安全起见，在本书所有的后续程序中，我们都将坚持使用声明函数原型的方式。
2. >通过定义一组小巧、独立、并能够完成事先良好界定的单个任务的函数，我们可以在这组函数上建立更加复杂的程序，并将这组函数应用于其他相似的任务之中。
3. >所有的C语言编译器都会忽略关于形式参数数组长度的声明，编译器只关心该函数的形式参数的类型是一个数组，而不需要了解数组的具体长度。

---

### 1.6.1 赋值表达式

1. >在数组中，乘等操作符的作用，是将操作符左面的表达式的值与操作符右面的表达式的值相乘，并将结果重新保存在左面的表达式中。
2. >还有一个重要的法则需要牢记：如果我们把数组作为参数传递给某个函数，并在哈数中改变数组元素的值，那么这些改变在函数调用结束之后依然保留。
3. >为什么在C语言中将普通变量作为参数时，函数不能改变其值，而将数组作为参数的时候，函数就能改变其值呢？这是因为：当我们调用某个函数的时候，调用参数的值是被拷贝到形式参数之中，无论对于数组还是普通变量，这个原则都是正确的。但是对于数组来说，我们并不是把实际的整个数组拷贝到形式参数的数组中，而是把实际的数组所在的内存位置拷贝到形式参数之中，因此在函数中对形式参数所代表数组的任何元素的操作，实际上是对实际参数所代表数组进行的操作，而不是对于实际数组的副本进行操作，因此当函数返回的时候，对实际数组的改变就保留下来了。

---

### 1.6.2 数组排序

1. >因为排序是计算科学中极其常见的一类问题，所以科学家们花费了很多精力研究与排序相关的算法。
2. >对于给定的一组信息，如何使用最少的时间和计算机内存对其进行排序已经有了很多成熟的算法。
3. >所谓升序的意思就是将数组中的元素按照其大小递增排列。在升序排序之后，数组中最小的元素排列在数组的第一个位置，最大的元素在最后一个位置，其他的元素也按照从小到大的顺序依次排列。
4. >具体如何进行数组的升序排列呢？首先，我们把数组的第一个元素与第二个元素进行比较，如果第一个元素大于第二个元素，我们就交换这两个元素--也就是交换这两个元素中保存的数值；接下来，我们把数组中的第一个元素（我们已经知道这个元素是数组的头两个元素中较小的那个）和数组中的第三个元素进行比较。如果第一个元素大于第三个元素，我们同样交换这两个数组元素，否则的话，我们就保持他们原来的位置不动。经过这个步骤之后，数组前三个元素中最小的一个就保存在数组中的第一个位置。 如果我们重复上述过程，直到最后一个元素，那么在上述过程结束之后，数组的第一个位置中就保存着数组中的最小元素。如此进行下去之后，整个数组的元素就已经按照升序重新排列了。
5. >sort函数使用了一组嵌套循环来实现我们的排序算法。
6. >程序中的sort函数相当简单，为了这种简单，我们付出的代价是程序的执行时间。
7. >如果我们必须对很大的数组进行排序（例如包含有上千个元素），那么使用书中给出的sort函数的程序可能就需要运行相当长的一段时间；如果我们想要更快的完成排序工作的话，必须使用更为精巧复杂的算法。

---

### 1.6.3 多维数组

1. >如果普通变量和一维数组元素一样，我们也可以将多维数组作为参数传递给函数。
2. >我们也可以像一维数组那样，将整个多维数组作为参数传递给函数，只要在调用的时候我们给出数组的名字就可以了。
3. >如果在函数中修改了多维数组的值，那么实际的多维数组的元素也将发生改变。
4. >如果函数的形式参数是一维数组的时候，可以在函数声明和定义中忽略掉数组的长度，仅仅需要给出一对方括号，通知编译器这个形式参数是一个数组即可。
5. >对于二维数组，我们可以省略数组的行数，但是函数的声明中必须说明每一行中包含多少个元素，也就是说我们必须说明二维数组的列的个数。
6. >在一个函数嵌套的for循环中，外层循环用于遍历二维数组的每一行，对于变量的每一行，内层循环用于遍历其每一列上的元素。
7. >在显示某个特定的矩阵元素的时候，我们在printf函数中调用中使用格式化字符串%i，这样可以确保所有输出的矩阵元素都是对齐的。
8. >在完成输出某一行元素之后，我们在后面附加输出一个换行符号，这样二维数组的下一行输出就会另起一行。

---

### 1.6.4 函数与可变长度的多维数组

1. >C语言支持变量长度数组，我们可以利用这个特性编写接收任意大小数组参数的函数。
2. >我们将矩阵作为数组的形式参数，其大小也必须作为参数传递给函数，并且这两个形式参数的定义必须在数组形式参数的前面，只有这样，编译器才能知道如何处理函数的调用。

---

### 1.7 全局变量

1. >局部变量只能在定义它的函数内被访问，对于全局变量则没有这个限制。也就是说，程序中的任何函数都可以访问全局变量的值。
2. >与局部变量不同，全局变量的声明应该放置在程序的任何函数之外，这种声明形式告诉编译器该变量是全局性质的--它从不属于任何函数。程序中的任何函数都可以按照需要读取和修改该变量的值。
3. >全局变量最多的用途是多个函数需要存取同一个变量的场合。通过声明全局变量，我们不需要将某个数值在函数之间传来传去，而是直接在函数中引用该数值。
4. >使用全局变量有一个缺点：因为函数中使用了全局变量，它的通用性就有所下降。每次当我们重用该函数的时候，我们的必须保证对应的全局变量存在，而且名字也要和函数中使用的名字相一致。
5. >虽然使用全局变量可以减少传递给函数的参数个数，但是我们付出的代价是函数的通用性，有时候还包括程序的可读性。
6. >全局变量影响程序的可读性主要体现在两个方面：一个是无法通过阅读函数的开头部分就得知函数使用的所有变量；第二个是仅仅通过阅读函数的调用语句，无法得知函数所需的所有输入和输出。
7. >有些编程者采用了这样一个约定：给所有的全局变量名前面加上一个字母g。采用这种命名约定后，我们就能够很方便地把全局变量和局部变量区分开来。通过这些区分的变量名，阅读者就清楚该到哪儿去寻找这些变量的具体定义。
8. >所以的全局变量的初始值都为0，而局部变量的初始值是不确定的，需要在程序中显式地进行初始化。

---

### 1.8 自动变量与静态变量

1. >在声明自动变量的时候，可以咋变量声明前面加上关键字auto。在每次函数调用的时候，所以的自动变量实际上重新创建出来--也就是分配内存空间。
2. >在声明自动变量的时候，我们可以给它赋初值。实际上，初值可以是任何表达式。每当我们调用函数的时候，这个表达式的值将被重新计算并赋给该自动变量。也就是说，编译器保证保存在自动变量中的值，在函数调用结束之后就会消失，而决不会保存到下次调用的时候。
3. >如果我们在变量声明前面放置关键字static，那么情况就完全不同了。在C语言中，static并不代表静电，而是意味着某些东西是静态的。
4. >静态变量的核心思想是：它不会随着函数的调用和推出发生变化。也就是说，在上次调用函数的时候，如果我们给静态变量赋了某个值的haul，下次调用该函数的时候，这个值将保持不变。
5. >静态变量的初始化也与自动变量不同。静态局部变量的初始化只在程序开始的时候执行一次，而不是在每次调用函数的时候都进行。另外，静态局部变量的初始化表达式必须是一个常量或者常量表达式。
6. >静态变量的初始化值为0，这一点也与自动变量不同。
7. >声明局部变量是静态的还是自动的，要根据程序的需要决定，如果我们需要某个变量的值在多次调用之间保留下来（比如该变量用于保存函数被调用的次数），那么我们可以使用静态变量；如果函数的值只需初始化一次，以后不会改变，那么我们也可以将变量声明为静态变量，这样可以避免每次都初始化该变量，从而提高程序的效率。
8. >如果一个局部变量的值每次都需要初始化，那么使用自动变量看上去就更符合逻辑一些。

---

### 1.9 递归函数

1. >C语言支持对于函数的递归调用。
2. >递归函数可以非常简洁和有效地解决某些计算问题，这类问题通常的求解步骤能够归结为：将同样的步骤应用于越来越小的问题子集，最终得出答案。
3. >最常用于展现递归函数能力的例子是计算正整数的阶乘。
4. >n的阶乘就是从1到n这n个数的乘积，用符号表示就是n!。
5. >0的阶乘是一种特殊情况，其值规定为1。
6. >在C语言中，每次当我们调用一个函数的时候--无论是递归调用或者非递归调用，该函数都会得到自己独有的一组局部变量和形式参数。
7. >函数是C语言中一种非常强有力的工具，将整个程序分解为独立的小程序的好处很多。

---
