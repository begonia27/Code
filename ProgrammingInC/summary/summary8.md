# 第八章 使用函数

* [1.1 定义函数](#11-定义函数)

---

* [1.2 参数与局部变量](#12-参数与局部变量)

  * [1.2.1 函数原型声明](#121-函数原型声明)

  * [1.2.2 自动局部变量](#122-自动局部变量)

---

* [1.3 函数的返回值](#13-函数的返回值)

---

* [1.4 函数的调用](#14-函数的调用)

  * [1.4.1 声明返回值类型以及参数类型](#141-声明返回值类型以及参数类型)

  * [1.4.2 检查函数的参数](#142-检查函数的参数)

---

* [1.5 自顶向下的程序设计](#15-自顶向下的程序设计)

---

* [1.6 函数与数组](#16-函数与数组)

  * [1.6.1 赋值表达式](#161-赋值表达式)

  * [1.6.2 数组排序](#162-数组排序)

  * [1.6.3 多维数组](#163-多维数组)

  * [1.6.4 函数与可变长度的多维数组](#164-函数与可变长度的多维数组)

---

* [1.7 全局变量](#17-全局变量)

---

* [1.8 自动变量与静态变量](#18-自动变量与静态变量)

---

* [1.9 递归函数](#19-递归函数)

---

## 1.1 定义函数

1. >一个 **函数定义** 的第一行（按照从左到有的顺序）告诉 **编译器** 四件事情：1.谁能够 **调用** 这个函数；2.函数 **返回值的类型** ；3. **函数** 的名字；4.函数的 **参数** 。
2. >与变量的选择类似，给函数选择一个 **有意义的名字** 是非常重要的。名字的选择往往大大地影响程序的 **可读性** 。
3. >*$C$* 语言程序的执行总是从 *$main$* 开始。
4. >函数名称后面的 *$一对小括号$* 告诉编译器，这个名字代表一个函数，在调用函数的时候，我们 **没有给函数传递任何参数** 。当计算机执行函数调用的时候，程序的 **流程将跳转** 到该函数。
5. >在 **打印** 出程序内的消息之后，函数的执行就 **结束** 了。程序的执行流程重新回到了 *$main$* 函数中 **调用函数的地方** 。
6. >在函数的最后可以 **增加** 一条语句： *$return;$* 因为函数被定义为 **不返回任何值** ，所以这个 *$return;$* 语句后面 **没有数值** 。
7. >在不返回值的函数中，这个 *$return;$* 语句是 **可有可无** 的。
8. >*$printf$* 和 *$scanf$* 函数也都是函数。它们与其他自定义的函数的 **主要区别** 在于， *$printf$* 和 *$scanf$* 函数是 **标准库** 的一部分，我们 **不需要** 动手去编写它。
9. >无论是调用标准库的函数，还是调用自己编写的函数，在 **函数调用返回** 之后，计算机都接着 **执行调用函数那条语句后面的语句** 。

---

## 1.2 参数与局部变量

1. >在调用函数的时候，我们总是向函数 **传递了若干个值** ，第一个通常是 **格式化字符串** ，后面的值则是 **需要显示的程序计算结果** ，这些值在 *$C$* 语言中被称为 **函数参数** 。
2. >使用函数的 **参数** 可以大大 **增加函数的灵活性** 。
3. >我们可以 **自定义** 接收参数的函数。

---

### 1.2.1 函数原型声明

1. >在函数 *$void calculateTriangularNumber (int n)$* 中,这行语句被称为 **函数原型声明** 。它的作用是告诉 **编译器** ， *$calculateTriangularNumber$* 是一个函数。该函数不返回任何值（用关键字 *$void$* 标明），函数参数的正式名字是形式参数。
2. >形式参数的名字可以是任何 *$C$* 语言合法的 **变量名** ，在编写程序的名字时，应该给 **形式参数** 尽可能起一个有意义的名字。
3. >一旦定义了一个形式参数，就可以在函数体的 **任何地方** 引用这个形式参数。
4. >函数原型声明下面的 **左大括号** 表示 **函数体** 正式开始，同样，我们还需要定义一个 **变量** 用作 **循环下标** 。
5. >这些变量的 **初始化方法** 和 **使用方法** 与以前在 *$main$* 函数中的 **使用方法** 相同。

---

### 1.2.2 自动局部变量

1. >在函数体 **内部的变量** 通常被称为 **自动局部变量** 。
2. >被称为自动局部变量是 **因为** 每次当函数被调用的时候，编译器 **自动创建** 这些变量，而且除了函数之外，程序的其他部分 **无法访问** 这些变量。
3. >如果在函数中声明变量的时候给期间赋予了初值，那么每次 **调用该函数** 的时候，该变量都会 **重新赋予** 该初值。
4. >从更 **规范** 一些的角度来讲，每次在函数体内 **定义变量** 的时候，都应该使用 *$auto$* 这个 **关键字** 。因为 *$c$* 语言编译器 **默认** 任何在函数体内部定义的变量 **都是自动局部变量** ，所以在编程实践中，我们通常 **省略** *$auto$* 这个关键字。

---

## 1.3 函数的返回值

1. >很多时候，我们并 **不想显示计算的结果** ，为此， *$C$* 语言提供了一种方便的机制-- **函数的返回值** ，利用这种机制， **一个函数可以将某个值返回给它的调用者** 。
2. >在函数中返回一个值通常采用如下的 **语法形式** ： *$return$* 表达式；这个语句将表达式的 **值** 返回给函数的调用者。
3. >有些程序员习惯在表达式的周围加上 **小括号** ，这属于 **个人风格** ，这些小括号本身并不是必须的。
4. >如果要从一个函数中 **返回一个值** ，仅仅使用 *$return$* 语句本身还不够，还需要在声明函数的时候 **声明函数的返回值类型** 。这个声明应该 **放在函数名之前** 。
5. >所有的 *$main$* 函数名前面都有一个 **关键字** *$int$* 。
6. >我们 **不一定必须** 把函数的返回值保存在某个变量中，在 *$main$* 函数中，我们也可以把函数的返回值 **直接传递** 给 *$printf$* 函数，然后 *$printf$* 函数再 **将其结果显示* 出来。
7. > *$C$* 语言的函数 **只能够返回一个值** 。
8. >不像其他的编程语言， *$C$* 语言对于函数和过程 **并不区分** ， *$C$* 语言中只有函数，每个函数可以返回一个值，或者 **不返回值** 。
9. >如果我们在声明函数的时候 **不指定函数的返回值类型** ，那么编译器就假定该函数返回一个 **整型数** --如果这个函数 **最终返回值** 的话。
10. >我们应该 **尽力避免** 省略对于函数返回值类型的声明，这是一种 **不好的** 编程习惯，应该尽力避免。
11. >在函数的声明语句中，我们在 **函数名前面** 加上了关键字 *$void$* ，随后如果我们像下面这条语句那样使用该函数，编译器就会 **报告错误信息** ： *$number = calcuteTriangularNumber(20)$* ;从某种意义是上来讲， *$void$* 类型就是 **没有数据类型** ，因此如果一个函数声明其返回值是 *$void$* 类型，就是说该函数并不返回值，因此 **不能用在表达式中** 。
12. >当我们在函数中改变形式参数的值的时候，绝对不会影响到变量的值。实际上，当我们把 **变量的值** 作为参数传递给函数的时候，系统会 **自动** 将该变量的值 **拷贝到形式参数中** 。随后，在函数之中对于形式参数的任何修改，都 **不会影响到变量** 。也就是说，一个函数 **永远无法修改** 它的 **参数** 的值，它只能 **修改** 这些参数的拷贝。
13. >我们 **传递给函数的参数** 应该和 **函数声明的参数类型** 保持 **一致** 。
14. >如果我们 **没有** 在程序中使用类型转换操作符将整型变量 **转换** 为浮点型的变量，那么 **编译器会自动进行转换**（编译器根据函数的 **声明** 已经得知函数需要的参数类型）。当然，我们也可以 **手动进行类似的转换** ，而不是依赖系统完成这些工作，这样可以使得程序 **显得更清楚** 一些。
15. >编译器在对函数的返回值进行处理的时候，依然使用我们前面讨论过的 **算术表达式求值规则** 。若函数的 **返回的值是一个浮点数** 时，编译器将除法表达式看作是一个浮点数除以一个整型数。由于除法操作数之一是一个浮点数，因此 **整个除法操作数都是用浮点算术规则** 。

---

## 1.4 函数的调用

1. >在书中示例 *$8.8中$* ，函数 *$absoluteValue$* 和函数 *$squareRoot$* 的形式参数的名字都是 *$x$* , *$C$* 语言编译器会 **自动区分** 它们，而不会产生混乱。
2. >实际上，每个函数都有自己的 **形式参数** ，因此函数 *$absoluteValue$* 和函数 *$squareRoot$* 的形式参数是 **完全不同** 的。
3. >在多个函数内，我们可以 **任意声明** 多个 **同名的变量** 。
4. >由于一个函数内定义的变量，也就是 **局部变量** ，只能在那个 **函数内部被访问** ，因此 *$C$* 语言编译器不会把它们搞混。也就是说，函数内部定义的变量，其 **作用域范围** 就是该函数。

---

### 1.4.1 声明返回值类型以及参数类型

1. > *$C$* 语言的编译器在遇到 **函数调用** 的时候，将假定函数的返回值是 **整型数** ，除非遇到以下两种情况：一个是在函数调用语句之前，编译器已经“看到了”该函数的 **具体定义** ；另一个是在函数的调用语句之前，编译器已经“看到了”该函数的 **声明** 。
2. >函数的原型声明不但可以告诉 **编译器** 函数的 **返回值类型** ，还包括函数需要的 **参数个数** 以及它们的 **数据类型** 。
3. >在声明函数原型的时候，我们可以 **只给出函数参数的类型** 而不必指定其名字，我们也可以在函数声明的时候给出参数的“哑”变量名，这个名字 **不必** 和函数定义时 **使用的参数名称相同** ，编译器将 **忽略** 这里给出的名字。
4. >为了 **防止拼写错误** ，我们可以简单地将 **函数定义过的第一行** 拷贝作为函数的声明，另外读者需要记住在 **函数声明的后面有一个分号** 。
5. >如果函数 **不需要任何参数** ，我们可以在 **函数参数括号** 之间使用关键字 *$void$* 。我们也需要在 **声明** 的时候指出这一点，以 **防止编译器** 将函数用于 **表达式中** 。
6. >如果函数 **接收不定数目的参数**（比如 *printf$* 函数和 *scanf$* 函数），我们可以用下面的方式 **通知编译器** ： *$int printf$* (char* format, *$\cdot\cdot\cdot$* );
7. >在 *$int printf$* (char* format, *$\cdot\cdot\cdot$* );这个声明中，它告诉了编译器， *$printf$* 函数的第一个参数是 **字符型指针** 。在这个参数后还可以 **有任意多个参数**（用 *$\cdot\cdot\cdot$* ）说明。
8. >文件 *$stdio.h$* 中包含了 *$printf$* 函数和 *$scanf$* 函数的 **原型声明** ，这也是我们为什么要在我们 **源文件** 开始放上如下代码：**#include <stdio.h>** 的原因。
9. >如果在程序的一开始 **没有这些声明** ，编译器将 **假定** *$printf$* 函数和 *$scanf$* 函数接收 **固定多个参数** ，并生成 **不正确的可执行代码** 。
10. > **编译器** 只有在已经看到了函数的定义或者函数原型的情况下，才能在函数调用的时候进行 **适当的类型转换** ，因此 **函数的声明** 是非常重要的。

---

### 1.4.2 检查函数的参数

1. >如果程序的 **循环结束条件** 永远都 **不会** 满足，程序将进入一个 **无限循环的局面** ，那么为了 **结束程序** ，我们必须在 **终端上按下** 某些特殊的键（比如 *$ctrl+C$* )。
2. >*$C$* 语言的 **标准库函数** *$sqrt$* 在 **接收一个负数参数** 时，将返回错误值 *$domain error$* 。这个符号的具体值是“和”实现相关的，在某些系统中，如果我们试图显示这个数字，将得到结果 *$nan$* ，这个意思是不是一个数字（ *$not a number$* ）。
3. >在 **单个的函数** 中可以有多个 *$return$* 语句，当程序遇到 *$return$* 语句的时候， **控制流程** 将会立刻回到 **调用者** ， *$return$* 语句后面的所有语句 **都不再被执行** 了。
4. >对于那些 **不返回任何值的函数** 来说， *$return$* 语句的这种用法非常方便，只要采用 *$return;$* 的简单形式就可以达到效果。
5. >对于 **需要返回某个值的函数** 来说，就 **不能使用** 这种形式 *$return$* 语句了。

---

## 1.5 自顶向下的程序设计

1. >一个函数可以 **调用另外一个函数** ，被调用的函数 **还可以调用** 其他的函数，依次下去，最终我们就得到一个 **结构良好的程序骨架** 。
2. >当我们开始编写一个函数的时候，还可以应用这种 **自顶向下的设计方法** ：我们可以 **声明一个函数** 并 **调用** 它，不需要操心这个函数的 **实现细节** ；在编写这个函数的时候，我们只需要 **确信** 将来能够书写函数，用它来 **解决实际的需要** 。
3. >这种自顶向下的程序设计的方法，不仅能帮助我们更容易地 **开发某个程序** ，也能够增加程序的 **可读性** 。比如：一个程序员阅读计算平方根的代码时，他并 **不需要仔细地阅读** 计算平方根的算法 **实现细节** ，就很容易知道这个程序计算了三个数字的平方根并将其显示出来，如果该程序员想要 **了解该程序的更多细节** ，他可以更仔细的 **阅读该函数中的代码** 。由于这些细节都被 **封装** 起来了，只有在必要的时候，才会被 **进一步研究** 。

---

## 1.6 函数与数组

1. >如同普通变量一样，在 *$C$* 语言中我们也能够将 **数组元素** 甚至是 **整个数组** 作为参数传递给函数。
2. >如果要将单个数组元素作为 **参数传递** 给某个函数，我们只要 **使用普通的数组元素表达式** 就可以了。
3. >函数中包含 **数组** 的示例：如果我们要计算数组元素 *$averages[i]$* 的平方根，并将结果保存在变量 *$sq_root_result$* 中，可以使用如下的语句： *$sq_root_result = squareRoot(averages[i])$* ；在函数 *$squareRoot$* 的内部，我们 **不需要针对** 数组元素采用任何 **特殊的措施** 。如同普通的变量一样，该 **数组元素的值** 被 **拷贝** 到形式参数中，然后 **在函数中** 正常使用。
4. >将 **整个数组** 作为参数传递给函数与传递给 **单个变量** 或 **数组元素** 完全不同。如果我们要把一个数组传递给某个函数，需要 **在参数调用的位置** 写上数组的名字， **不需要添加任何下标表达式** 。例如: *$gradeScores$* 是一个长度为 *$100$* 的数组，如果我们要把这个数组作为参数传递给 *$minmum$* 函数，可以使用下面的表达式， *$minimum(gradeScores);$* 另一方面，如果我们要 **声明参数为数组的函数** ，可以采用下面的形式：

```C
    int minimum(int values[100])
    {
      \cdot\cdot\cdot
      return minValue;
    }
```

1. >为了 **安全起见** ，在本书所有的后续程序中，我们都将坚持 **使用声明函数原型的方式** 。
2. >通过定义一组小巧、独立、并能够完成 **事先良好界定** 的 **单个任务的函数** ，我们可以在这组函数上 **建立更加复杂的程序** ，并将这组函数应用于其他 **相似的任务** 之中。
3. >所有的 *$C$* 语言编译器都会 **忽略** 关于 **形式参数数组长度的声明** ，编译器只关心该函数的 **形式参数的类型** 是一个数组，而 **不需要了解** 数组的具体 **长度** 。

---

### 1.6.1 赋值表达式

1. >在数组中， **乘等操作符** 的作用，是将 **操作符左面的表达式的值** 与 **操作符右面的表达式的值** 相乘，并 **将结果重新保存** 在左面的表达式中。
2. >还有一个 **重要的法则** 需要牢记：如果我们 **把数组作为参数** 传递给某个函数，并在函数中 **改变数组元素的值** ，那么这些改变在 **函数调用结束之后依然保留** 。
3. >为什么在 *$C$* 语言中将 **普通变量作为参数** 时，函数 **不能** 改变其值，而将 **数组** 作为参数的时候，函数就能 **改变其值** 呢？这是因为：当我们调用某个函数的时候，调用参数的 **值是被拷贝到** 形式参数之中，无论对于数组还是普通变量，这个原则都是正确的。但是对于数组来说，我们 **并不是把** 实际的整个数组拷贝到形式参数的数组中，而是 **把实际的数组所在的内存位置拷贝到形式参数** 之中，因此在函数中对形式参数所代表 **数组的任何元素的操作** ，实际上是对 **实际参数所代表数组** 进行的操作，而 **不是** 对于实际数组的 **副本** 进行操作，因此当函数返回的时候，对 **实际数组** 的改变就 **保留** 下来了。

---

### 1.6.2 数组排序

1. >因为 **排序** 是计算科学中极其常见的一类问题，所以科学家们花费了很多精力研究与排序相关的算法。
2. >对于给定的一组信息， **如何使用最少的时间和计算机内存对其进行排序** 已经有了很多成熟的算法。
3. >所谓 **升序** 的意思就是将数组中的元素 **按照其大小递增排列** 。在升序排序之后，数组中最小的元素排列在数组的第一个位置，最大的元素在最后一个位置，其他的元素也按照从小到大的顺序 **依次排列** 。
4. > **具体如何进行** 数组的升序排列呢？首先，我们把数组的第一个元素与第二个元素进行比较，如果第一个元素大于第二个元素，我们就交换这两个元素--也就是交换这两个元素中保存的数值；接下来，我们把数组中的第一个元素（我们已经知道这个元素是数组的头两个元素中较小的那个）和数组中的第三个元素进行比较。如果第一个元素大于第三个元素，我们同样交换这两个数组元素，否则的话，我们就保持他们原来的位置不动。经过这个步骤之后，数组前三个元素中最小的一个就保存在数组中的第一个位置。 如果我们 **重复上述过程** ，直到最后一个元素，那么在上述过程结束之后，数组的第一个位置中就保存着数组中的最小元素。如此进行下去之后，整个数组的元素就已经按照升序重新排列了。
5. > *$sort$* 函数使用了一组 **嵌套循环** 来实现我们的排序算法。
6. >程序中的 *$sort$* 函数相当简单，为了这种简单，我们付出的 **代价是程序的执行时间** 。
7. >如果我们必须对很大的数组进行排序（例如包含有上千个元素），那么使用书中给出的 *$sort$* 函数的程序可能就需要运行相当长的一段时间；如果我们想要更快的完成排序工作的话，必须 **使用更为精巧复杂的算法** 。

---

### 1.6.3 多维数组

1. >如果普通变量和一维数组元素一样，我们也可以将 **多维数组** 作为参数传递给函数。
2. >我们也可以像一维数组那样，将 **整个多维数组** 作为参数传递给函数，只要在调用的时候我们给出数组的名字就可以了。
3. >如果在函数中 **修改了** 多维数组的值，那么 **实际的多维数组的元素** 也将发生改变。
4. >如果函数的形式参数是一维数组的时候，可以在 **函数声明** 和 **定义** 中 **忽略** 掉数组的长度，仅仅需要给出 **一对方括号** ，通知编译器这个 **形式参数是一个数组** 即可。
5. >对于二维数组，我们可以 **省略数组的行数** ，但是函数的声明中 **必须说明** 每一行中包含多少个元素，也就是说我们 **必须说明二维数组的列的个数** 。
6. >在一个函数嵌套的 *$for$* 循环中， **外层循环** 用于遍历二维数组的 **每一行** ，对于变量的 **每一行** ， **内层循环** 用于遍历其 **每一列** 上的元素。
7. >在显示某个特定的 **矩阵元素** 的时候，我们在 *$printf$* 函数中调用中使用 **格式化字符串** **%i** ，这样可以确保所有 **输出的矩阵元素** 都是 **对齐** 的。
8. >在 **完成输出** 某一行元素之后，我们在后面 **附加输出一个换行符号** ，这样二维数组的下一行输出就会 **另起一行** 。

---

### 1.6.4 函数与可变长度的多维数组

1. > *$C$* 语言支持 **变量长度数组** ，我们可以利用这个特性编写接收 **任意大小数组参数的函数** 。
2. >我们将 **矩阵** 作为数组的形式参数，其 **大小** 也必须作为参数传递给函数，并且这两个形式参数的定义必须在数组形式参数的 **前面** ，只有这样，编译器才能知道 **如何处理函数的调用** 。

---

### 1.7 全局变量

1. >**局部变量** 只能在定义它的 **函数内** 被访问，对于 **全局变量** 则没有这个限制。也就是说，程序中的任何函数都 **可以访问** 全局变量的值。
2. >与局部变量不同，全局变量的声明应该 **放置在程序的任何函数之外** ，这种声明形式告诉编译器该变量是 **全局性质** 的--它从不属于任何函数。程序中的 **任何函数** 都可以按照需要 **读取** 和 **修改** 该变量的值。
3. >全局变量 **最多的用途** 是 **多个函数需要存取同一个变量的场合** 。通过声明全局变量，我们不需要将某个数值在函数之间传来传去，而是 **直接在函数中引用该数值** 。
4. >使用全局变量有一个 **缺点** ：因为函数中使用了全局变量，它的 **通用性就有所下降** 。每次当我们重用该函数的时候，我们的必须保证 **对应的全局变量存在** ，而且名字也要和函数中使用的名字 **相一致** 。
5. >虽然使用全局变量可以 **减少** 传递给函数的参数个数，但是我们付出的代价是函数的 **通用性** ，有时候还包括程序的 **可读性** 。
6. >全局变量影响程序的可读性主要体现在两个方面：一个是 **无法通过阅读函数的开头部分** 就得知函数使用的 **所有变量** ；第二个是仅仅通过阅读函数的调用语句， **无法得知** 函数所需的 **所有输入** 和 **输出** 。
7. >**有些编程者** 采用了这样一个约定：给 **所有的全局变量名前面** 加上一个字母 *$g$* 。采用这种命名约定后，我们就能够很方便地把全局变量和局部变量区 **分开** 来。通过这些区分的变量名，阅读者就清楚 **该到哪儿去寻找** 这些变量的具体定义。
8. >所以的全局变量的 **初始值** 都为 *$0$* ，而局部变量的初始值是 **不确定** 的，需要在程序中 **显式地进行初始化** 。

---

### 1.8 自动变量与静态变量

1. >在声明 **自动变量** 的时候，可以在变量声明前面加上关键字 *$auto$* 。在每次函数调用的时候，所以的自动变量 **实际上重新创建** 出来--也就是 **分配内存空间** 。
2. >在声明自动变量的时候，我们可以给它 **赋初值** 。实际上，初值可以是 **任何表达式** 。每当我们调用函数的时候，这个表达式的值将被 **重新计算** 并赋给该自动变量。也就是说，编译器保证保存在自动变量中的值，在函数 **调用结束之后就会消失** ，而决 **不会保存** 到下次调用的时候。
3. >如果我们在 **变量声明前面** 放置关键字 *$static$* ，那么情况就完全不同了。在 *$C$* 语言中， *$static$* 并不代表静电，而是意味着 **某些东西是静态的** 。
4. >静态变量的 **核心思想** 是：它 **不会随着** 函数的调用和退出发生变化。也就是说，在上次调用函数的时候，如果我们 **给静态变量** 赋了某个值的话，下次调用该函数的时候，这个 **值将保持不变** 。
5. >静态变量的 **初始化** 也与自动变量不同。静态局部变量的初始化 **只在程序开始的时候** 执行一次，而 **不是** 在每次调用函数的时候都进行。另外， **静态局部变量的初始化表达式** 必须是一个 **常量** 或者 **常量表达式** 。
6. >静态变量的 **初始化值** 为 *$0$* ，这一点也与自动变量不同。
7. >声明局部变量是静态的还是自动的，要根据 **程序的需要** 决定，如果我们需要 **某个变量的值** 在多次调用之间 **保留** 下来（比如该变量用于保存函数被调用的次数），那么我们可以使用 **静态变量** ；如果函数的值 **只需初始化一次** ，以后不会改变，那么我们也可以将变量声明为静态变量，这样可以 **避免每次都初始化** 该变量，从而 **提高程序的效率** 。
8. >如果一个局部变量的 **值每次都需要初始化** ，那么使用 **自动变量** 看上去就更符合逻辑一些。

---

### 1.9 递归函数

1. > *$C$* 语言支持对于函数的 **递归调用** 。
2. >递归函数可以非常简洁和有效地解决某些计算问题，这类问题通常的 **求解步骤** 能够归结为： **将同样的步骤应用于越来越小的问题子集，最终得出答案** 。
3. >最 **常用于** 展现递归函数能力的 **例子** 是 **计算正整数的阶乘** 。
4. >*$n$* 的 **阶乘** 就是从 *$1$* 到 *$n$* 这 *$n$* 个数的 **乘积** ，用符号表示就是 *$n!$* 。
5. >*$0$* 的阶乘是一种 **特殊情况** ，其值 **规定** 为 *$1$* 。
6. >在 *$C$* 语言中，每次当我们调用一个函数的时候--无论是递归调用或者非递归调用，该函数都会得到自己 **独有的一组局部变量** 和 **形式参数** 。
7. >函数是 *$C$* 语言中一种非常 **强有力的工具** ，将整个程序分解为 **独立的小程序** 的好处很多。

---
